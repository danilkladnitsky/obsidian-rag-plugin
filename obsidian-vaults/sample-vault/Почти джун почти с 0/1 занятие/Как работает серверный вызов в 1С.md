---
tags:
  - 1С
---
Клиент-серверная архитектура заложена в платформе изначально – со времен «1С:Предприятие 8.0».

Однако при разработке на 8.0 и 8.1 о разделении кода на клиентскую и серверную часть **можно было не заботиться**, поскольку на клиенте (на толстом клиенте) был доступен тот же функционал, что и на сервере.

Всё изменилось с выходом платформы «1С:Предприятие 8.2», когда появился **тонкий клиент**. Теперь на клиенте доступен один функционал, на сервере – другой. Клиент и сервер «общаются» между собой с помощью **серверного вызова**.

Конечно, это усложнило процесс разработки, но с другой стороны – можно создавать более **оптимальные** (быстрые) решения, поскольку все сложные задачи выполняются на сервере.

## Немного базовой теории

Перед тем, как перейти к содержательной части, **договоримся о некоторых ограничениях**:

- Мы подразумеваем, что Вы знаете о существовании четырёх директив компиляции, доступных в модулях формы: «`&НаКлиенте`», 
  «`&НаСервере`», «`&НаСервереБезКонтекста`» и 
  «`&НаКлиентеНаСервереБезКонтекста`».
- Все примеры будут опираться на работу «1С:Предприятие 8» в клиент-серверном режиме. Файловый вариант по сути является эмуляцией клиент-серверного режима, с небольшими отклонениями (для данной статьи это не критично)
- В рамках этого материала рассматривается исключительно взаимодействие клиента и сервера 1С. Работа с базой данных, преобразование данных и прочие нюансы работы системы – это темы других статей.

Директивы, в имени которых упоминается «Клиент», устанавливают ограничение на обращение к базе данных.

Процедуры или функции, написанные под директивой «Без контекста», не имеют доступа к контексту (данным) формы. Исходя из этой информации, легко представить ограничения директив по доступу к данным в виде следующей таблицы:

| Директива                         | Данные формы | База данных |
| --------------------------------- | ------------ | ----------- |
| `&НаКлиенте`                      | +            | -           |
| `&НаСервере`                      | +            | +           |
| `&НаСервереБезКонтекста`          | -            | +           |
| `&НаКлиентеНаСервереБезКонтекста` | -            | -           |
Опережая вопрос «Для чего же директива с самым длинным названием, если она ограничивает и использование контекста форм, и обращения к базе данных?», напомню: любая процедура и функция поддерживает обработку информации, переданной в неё в качестве параметров.

Отсюда делаем вывод: у методов, описанных под директивой «`&НаКлиентеНаСервереБезКонтекста`», единственным источником данных являются эти самые переданные параметры.

Не стоит забывать и про доступность вызова одних процедур и функций из других. Для этого стоит запомнить, что можно вызывать только те процедуры и функции, которые находятся под одноимённой (с родительским методом) директивой или под директивой, находящейся ниже (чем у родительского метода) согласно списку:

- `&НаКлиенте`
- `&НаСервере`
- `&НаСервереБезКонтекста`
- `&НаКлиентеНаСервереБезКонтекста`.

То есть из метода, описанного под директивой «`&НаКлиенте`», можно вызывать процедуры и функции, описанные под любой директивой. А вот «из-под» директивы «`&НаСервереБезКонтекста`» можно вызывать только то, что описано под директивой «`&НаСервереБезКонтекста`» или «`&НаКлиентеНаСервереБезКонтекста`».
## Теперь про серверный вызов

**Серверный вызов** – это передача какой-то информации с клиентской части «1С:Предприятие 8» на серверную часть с целью вернуть обратно некий набор данных.

Самый первый серверный вызов инициализируется в момент начала сеанса работы 1С. То есть когда пользователь выполняет вход в информационную базу:

![[Pasted image 20240721110702.png]]

![[Pasted image 20240721110731.png]]

Обратите внимание, что доступ к базе данных есть только на серверной части, а соединение между клиентом и сервером имеет ограниченную пропускную способность. Это и неудивительно – ведь соединение между клиентской и серверной частью может быть установлено даже по нестабильному низкоскоростному каналу связи (например, посредством мобильного интернета).

Кроме этого, передача данных между клиентом и сервером возможна только посредством серверного вызова.

![[Pasted image 20240721110838.png]]


|                                          |                                                                                                                                                                                                                                                                                                  |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ![[Pasted image 20240721111006.png\|75]] | Это **процесс клиентской части приложения «1С:Предприятие 8»**. Он запускается на компьютере пользователя и сожительствует в оперативной памяти с другими процессами (38 вкладок браузера, поток аудио из социальной сети, telegram и другие). Может порождать серверный вызов.                  |
| ![[Pasted image 20240721111437.png\|75]] | Это **процесс серверной части приложения «1С:Предприятие 8»**. Он существует на сервере 1С. Знает, какие клиентские сеансы в данный момент запущены, но самостоятельно не может инициировать взаимодействие с ними. Работает с клиентской частью только через полученный от неё серверный вызов. |
| ![[Pasted image 20240721111559.png\|75]] | А это **серверный вызов**. Как было сказано выше, он порождается процессом клиентской части и призван «прислуживать» ему. Он передает запросы со стороны клиента на сторону сервера, а также занимается транспортировкой данных с клиента на сервер и обратно.                                   |

### Действие 1. Открытие пользователем формы с данными.

![[Pasted image 20240721111722.png]]

> В момент нажатия Пользователем кнопки открытия формы из интерфейса, происходит передача управления на Сервер. По переданным параметрам получаются необходимые для построения данные из БД и происходит формирование контекста формы, который затем отправляется на клиентскую часть. У пользователя на экране отображается запрошенная форма.

### Действие 2. Получение из открытой Пользователем формы дополнительных данных из Базы данных.

![[Pasted image 20240721112049.png]]

Получение этих данных может быть описано под двумя директивами – «`&НаСервере`» и 
«`&НаСервереБезКонтекста`». Рассмотрим оба случая.
#### Явление 1. Директива «`&НаСервере`»

![[Pasted image 20240721112215.png]]

>  При вызове процедуры или функции под директивой «`&НаСервере`» из формы со стороны клиента происходит «упаковка» всего контекста формы и отправка его на сторону сервера.
>  После выполнения метода на сервере, весь этот «пакет» транспортируется обратно. Таким образом, форма со всеми элементами и данными дважды проходит через самое узкое место системы.
#### Явление 2. Директива «`&НаСервереБезКонтекста`»

![[Pasted image 20240721112333.png]]

> При вызове процедуры или функции под директивой «`&НаСервереБезКонтекста`» из формы со стороны клиента происходит передача на сторону сервера только тех данных, которые были указаны в качестве параметров. Обратно же передаётся только необходимая информация в уже подготовленном виде.
> Таким образом, серверный вызов не несёт лишней нагрузки, и для передачи данных между клиентом и сервером потребуется меньше ресурсов.

Из примеров видно, что далеко не всегда оправдано указание директивы компиляции «`&НаСервере`» с точки зрения использования контекста (данных) формы на сервере.

Если возможно решить возникшую задачу путём отправки на сервер только определённого набора данных, то надо эту возможность использовать и описывать метод под директивой 
«`&НаСервереБезКонтекста`». Это позволит уменьшить нагрузку на серверный вызов, а также не занимать сервер обработкой и хранением ненужной в текущий момент информации.

Но использование директивы «`&НаСервереБезКонтекста`» не является панацеей. Помимо нагрузки на серверный вызов, всегда необходимо задумываться ещё над одним параметром.
### Действие 3. Обработка данных табличной части формы с получением дополнительной информации из Базы данных.

![[Pasted image 20240721113139.png]]
#### Явление 1. Построчная обработка табличной части на стороне клиента с организацией серверного вызова для получения дополнительной информации из базы данных.

Мы уже знаем – лучше использовать директиву «`&НаСервереБезКонтекста`».

![[Pasted image 20240721113327.png]]

![[Pasted image 20240721113348.png]]


> При таком построении программного кода происходит множественное обращение со стороны клиента на сервер – по количеству элементов цикла, запущенного на стороне клиента.
#### Явление 2. Предварительная обработка табличной части на стороне клиента с целью подготовки требуемых к обработке на сервере данных и «упаковки» их в набор параметров. Затем передача этого набора на сервер для получения дополнительной информации из базы данных.

Используем всё ту же директиву «`&НаСервереБезКонтекста`».

![[Pasted image 20240721113520.png]]


> В данном случае количество серверных вызовов сведено к минимуму за счёт предварительной подготовки параметров.

Большое количество текущих серверных вызовов может свидетельствовать о неоптимальном программном коде.

Избегайте создания серверных вызовов внутри цикла. Подготовьте набор параметров и единожды выполните его передачу для обработки на сервер. Если предполагается сложная обработка большого количества данных формы – передайте её полностью на сервер (при помощи директивы «`&НаСервере`») и выполните все действия на стороне сервера.


> Если цель серверного вызова, созданного внутри цикла – получить какую-либо информацию из базы данных, то данная операция включает в себя запрос в цикле. А это очень негативно влияет на производительность всей системы в целом.

С директивой «`&НаСервереБезКонтекста`» вроде бы разобрались. Она нужна для того, чтобы уменьшить объем информации, передаваемой в рамках одного серверного вызова. Дополнительно разобрались с количеством текущих серверных вызовов – необходимо стремиться к их минимизации.

Давайте теперь попробуем разобраться, для чего нужна директива «`&НаКлиентеНаСервереБезКонтекста`».
### Действие 4. Выполнение обработки данных.

Когда предполагается выполнение одной и той же обработки данных из нескольких участков программного кода, разумно этот код поместить в самостоятельную процедуру или функцию. Остаётся только решить, под какой директивой её написать.

![[Pasted image 20240721113908.png]]


|                                          |                                                                                                                                                                                                                                                                       |
| ---------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![[Pasted image 20240721115833.png\|75]] | Для копирования у нас есть ксерокс. Но куда его поставить? На сторону клиента или сервера? Под какой директивой его разместить?<br><br>Как было озвучено ранее – любая процедура и функция поддерживает обработку информации, переданной в неё в качестве параметров. |

Давайте для начала попробуем разместить копировальный аппарат на стороне клиента. Для этого описываем процедуру или функцию «Ксерокс» под директивой «`&НаКлиенте`». Тогда процесс клиентской части в любой момент сможет без проблем обратиться к ней и все действия будут выполнены в соответствии с программным кодом.

Но что произойдёт, если потребность в копировании возникнет на стороне сервера? Например, для подготовки данных, передаваемых на сторону клиента, потребуется сделать копию? Напомню – процесс серверной части не имеет возможности самостоятельно инициировать клиентские вызовы.

![[Pasted image 20240721115946.png]]

Получается, что использовать директиву «`&НаКлиенте`» неправильно, а директиву «`&НаСервере`», как мы изучили ранее – нежелательно. Давайте посмотрим поведение системы при использовании директивы «`&НаСервереБезКонтекста`».

![[Pasted image 20240721120027.png]]

Вроде бы результат достигнут – и с сервера, и с клиента доступно копирование. Но для того, чтобы получить копию данных, используемых на клиенте, приходится делать серверный вызов. А это опять ведет к лишней нагрузке на соединение и временным затратам.

Избавиться от излишней передачи на сервер при сохранении возможности копирования на клиенте и на сервере можно при помощи директивы «`&НаКлиентеНаСервереБезКонтекста`».

![[Pasted image 20240721120103.png]]

Не углубляясь в детали, отметим, что метод, описанный под данной директивой управления, создаётся в двух копиях – и на стороне клиента, и на стороне сервера. Это позволяет выполнить необходимые действия там, где появилась потребность в них (клиент/сервер), без лишних серверных вызовов.

> Конечно, вместо того чтобы выделять повторяющийся программный код, описывать его в отдельном методе под директивой «&НаКлиентеНаСервереБезКонтекста», можно поступить по-другому. Просто взять и написать один и тот же участок кода и в клиентской, и в серверной процедуре.
> С точки зрения выполнения программы результат будет одинаков. Но объяснение «почему так не надо делать» – это уже совершенно другая тема…
## Вместо заключения

**Основная причина для выбора правильной директивы – производительность транспортировки данных между клиентской и серверной частью.**

Придерживайтесь при разработке следующих правил:
- По возможности не передавайте контекст формы на сторону сервера
- Минимизируйте количество текущих серверных вызовов
- Длительные и ресурсоёмкие задачи запускайте на выполнение на стороне сервера (при возможности – в фоновом режиме).

Учитывайте потребность в доступности тех или иных видов данных, обоснованность передачи управления и не стесняйтесь при необходимости дробить процедуры и функции. И будет Вашему серверному вызову всегда легко, а Вы от пользователей Вашей программы получите «молчаливую благодарность»!


> Так ли это важно думать об оптимизации? Тут имеет смысл вспомнить одну историю.
> Программист Иван при доработке 1С на своём предприятии сделал ошибку в выборе директивы компиляции. Из-за неё длительность одного из серверных вызовов была больше возможной на полсекунды.
> 
> Пользователей, применяющих этот функционал, – 25 человек, и каждый из них за рабочий день в среднем совершает 110 таких операций. Всего впустую за рабочий месяц потрачено 28875 секунд (21 рабочий день * 25 человек * 110 операций * 0,5 секунды) = 8,02 часов.
> 
> Иван, каково тебе осознавать, что за месяц ты задолжал своему предприятию целый рабочий день?

---
tags:
  - 1С
---
## Задача

В процессе работы прикладного решения часто бывает нужно передавать данные из одной формы в другую. Примером такого обмена данными между формами является передача табличной части из формы документа в форму подбора и обратно.

Можно передавать данные через клиент в параметре типа `ДанныеФормыКоллекция`, а можно использовать для этого временное хранилище, работа с которым будет происходить на сервере.

С одной стороны, при передаче данных через клиент мы минимизируем вызовы сервера. Но объем передаваемых данных может быть при этом довольно большим. Кроме того, поскольку на клиенте присутствуют не все данные коллекций форм, а только их видимая часть, то данные при передаче будут постепенно «дочитываться» с сервера.

С другой стороны, этого можно избежать, передавая данные через временное хранилище, минуя клиент, хотя для этого и потребуются дополнительные вызовы сервера.

Посмотрим, какое решение более оптимально. Рассмотрим пример.

Предположим, в табличную часть документа `РасходнаяНакладная` подбираются товары из справочника `Товары`. При нажатии кнопки `Подбор`, расположенной в форме документа, должна открываться форма подбора, в которую передаются строки табличной части документа. После того как пользователь произведет подбор товаров из справочника и закроет форму подбора, отобранные товары передаются обратно в табличную часть расходной накладной (рис. 4.66).

![[Pasted image 20240804191821.png]]

Рассмотрим возможные варианты решения этой задачи.
## Первый вариант решения

Итак, создадим форму документа `РасходнаяНакладная`. Создадим команду формы `Подбор` и перетащим ее в командную панель таблицы формы `Товары`. Обработчик команды `Подбор` заполним следующим образом:

```js
&НаКлиенте
Процедура Подбор(Команда)

	ПараметрыПодбора = Новый Структура("ТчТоваровДокумента", Объект.Товары);
	ФормаПодбора = ОткрытьФорму("Документ.РасходнаяНакладная.Форма.ФормаПодбора",
		ПараметрыПодбора, ЭтаФорма);

КонецПроцедуры
```

В этом обработчике мы создаем структуру `ПараметрыФормы` и добавляем в нее элемент `ТчТоваровДокумента`, который будет содержать табличную часть документа (`Объект.Товары`). Затем мы открываем форму подбора документа `ФормаПодбора` с параметром типа `ДанныеФормыКоллекция` как подчиненную форме документа.

Теперь создадим форму документа с именем `ФормаПодбора` с основным реквизитом `СписокТоваров` типа `ДинамическийСписок`, отражающим данные справочника `Товары`.

Затем создадим реквизит формы `ОтобранныеТовары` типа `ТаблицаЗначений` (с колонками `Товар` типа `СправочникСсылка.Товары` и `Количество` типа `Число`), который будет содержать список отобранных товаров и их количество.

Перетащим реквизиты `СписокТоваров` и `ОтобранныеТовары` в форму, а также зададим свойства этих таблиц формы: `Заголовок`, `ПоложениеЗаголовка` – Верх, `ПоложениеКоманднойПанели` – Нет. Зададим также свойство формы `Заголовок` – «Подбор товара» и выключим свойство `Автозаголовок`, `ПоложениеКоманднойПанели` – Низ.

Чтобы обеспечить заполнение реквизита `ОтобранныеТовары` данными табличной части расходной накладной, создадим обработчик события формы `ПриСозданииНаСервере` и заполним его следующим образом:

```js
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)

	ТчТоваровДокумента = Параметры.ТчТоваровДокумента;

	Для Каждого ТоварТч Из ТчТоваровДокумента Цикл

		Элемент = ОтобранныеТовары.Добавить();
		Элемент.Товар = ТоварТч.Товар;
		Элемент.Количество = ТоварТч.Количество;

	КонецЦикла;

КонецПроцедуры
```

В этом обработчике мы в цикле обходим коллекцию данных, содержащуюся в параметре формы `ТчТоваровДокумента`, и заполняем таблицу значений `ОтобранныеТовары` элементами этой коллекции.

Таким образом, список отобранных товаров при открытии формы подбора будет заполнен данными табличной части расходной накладной.

Затем реализуем возможность добавления товаров из списка товаров в таблицу отобранных товаров. Для этого создадим обработчик события `ВыборЗначения` у таблицы формы `СписокТоваров` и включим у этой таблицы свойство `РежимВыбора`:

```js
&НаКлиенте
Процедура СписокТоваровВыборЗначения(Элемент, Значение, СтандартнаяОбработка)

	СтандартнаяОбработка = Ложь;
	ДобавитьТовар(Значение);

КонецПроцедуры
```

В модуле формы поместим процедуру `ДобавитьТовар()`, в которой выполняется добавление товаров из списка товаров в таблицу отобранных товаров. Но заметим, что эта процедура не имеет отношения к передаче данных между формами:

```js
&НаКлиенте
Процедура ДобавитьТовар(Товар)

	Элемент = ОтобранныеТовары.Вставить(0);
	Элемент.Товар = Товар;
	Элемент.Количество = 1;
	Элементы.ОтобранныеТовары.ТекущаяСтрока = Элемент.ПолучитьИдентификатор();

КонецПроцедуры
```

Затем, при нажатии кнопки `ОК`, форма подбора должна закрываться, и список отобранных товаров должен передаваться обратно в табличную часть расходной накладной. Для этого создадим команду формы подбора `ОК` и перетащим ее в командную панель формы. Отключим свойство командной панели `Автозаполнение` и установим свойство `ГоризонтальноеПоложение` – Право. Также перетащим в командную панель формы команду `Отмена` из списка стандартных команд формы.

Обработчик команды `ОК` заполним следующим образом:

```js
&НаКлиенте
Процедура ОК(Команда)

	ВладелецФормы.ОбработатьПодбор(ОтобранныеТовары);
	Закрыть();

КонецПроцедуры
```

В этом обработчике, перед тем как закрыть форму подбора, мы вызываем экспортируемую процедуру `ОбработатьПодбор()` владельца формы, то есть формы объекта – документа `РасходнаяНакладная`, и передаем в нее список отобранных товаров:

```js
&НаКлиенте
Процедура ОбработатьПодбор(ОтобранныеТовары) Экспорт

	Объект.Товары.Очистить();
	Для Каждого ТоварТч Из ОтобранныеТовары Цикл

		Элемент = Объект.Товары.Добавить();
		Элемент.Товар = ТоварТч.Товар;
		Элемент.Количество = ТоварТч.Количество;

	КонецЦикла;

	Модифицированность = Истина;

КонецПроцедуры
```

В этой процедуре, помещенной в модуле формы документа `РасходнаяНакладная`, мы очищаем табличную часть документа, затем в цикле обходим коллекцию данных, содержащуюся в параметре `ОтобранныеТовары`, и заполняем табличную часть документа элементами этой коллекции. И затем свойство формы `Модифицированность` устанавливаем в значение `Истина`, так как мы изменили табличную часть документа.

Таким образом, табличная часть расходной накладной при закрытии формы подбора по кнопке `ОК` будет заполнена списком отобранных товаров.

Запустим «1С:Предприятие», откроем документ Расходная накладная №  3 (он содержит 1000 позиций товаров) и нажмем кнопку `Подбор`. После этого откроется форма подбора, в которую будут переданы строки табличной части документа.

Посмотрим, сколько вызовов сервера при этом произойдет и какой будет объем передаваемых данных между клиентом и сервером.

![[Pasted image 20240804200625.png|500]]

Мы видим, что сервер вызывается 29 раз. Один вызов происходит, чтобы открыть форму подбора, и 28 вызовов сервера тратятся на «дочитывание» строк табличной части в форму документа на клиент порциями по 35 строк.

Объем принятых данных отражает ситуацию, когда табличная часть «доехала» в форму документа на клиент, так как с клиента мы «отправляем» `Объект.Товары` в параметрах открываемой формы.

Объем отправленных данных отражает ситуацию, когда вся табличная часть с клиента «уехала» на сервер, так как она передается в параметре метода `ОткрытьФорму()`.

Для наглядности рассмотрим схему передачи данных между клиентом и сервером (рис. 4.67).

![[Pasted image 20240804200837.png]]

После того как пользователь произведет подбор товаров из справочника (в нашем примере выбран всего один товар) и закроет форму подбора, отобранные товары и их количество будут переданы обратно в табличную часть расходной накладной (рис. 4.66).

Посмотрим теперь на показатели производительности.

![[Pasted image 20240804200917.png|500]]

28 вызовов сервера тратятся на «дочитывание» строк таблицы значений `ОтобранныеТовары` в форму подбора на клиент порциями по 35 строк.

Объем принятых данных отражает ситуацию, когда таблица `ОтобранныеТовары` «доехала» в форму подбора на клиент, так как с клиента мы вызываем процедуру `ОбработатьПодбор()`, в которую передаем эту таблицу в качестве параметра.

Для наглядности рассмотрим схему передачи данных между клиентом и сервером (рис. 4.68).

![[Pasted image 20240804201027.png]]

Может возникнуть вопрос: «Почему в первой таблице, когда в форму документа дочитывалась табличная часть, было передано 153302, а тут, когда те же данные дочитываются в форму подбора, передано всего 97690?»

Дело в том, что в первой таблице дочитывалась именно табличная часть. Во второй таблице дочитывалась не табличная часть, а таблица значений. Таблица значений устроена проще, чем табличная часть, поэтому она сериализуется лучше (объем данных меньше). Кроме того, в первом примере табличная часть содержит три колонки, а таблица значений во втором случае содержит всего две колонки. За счет этого во втором случае и получается меньший объем принятых данных.

В результате мы добились нужной функциональности формы, но при большом массиве передаваемых данных такой вариант обмена данными между формами будет неоптимальным.

Для наглядности рассмотрим схему программного взаимодействия клиента и сервера
(рис. 4.69).

![[Pasted image 20240804201216.png]]

Как мы видим, при открытии формы подбора платформа делает вызов сервера.

Но при этом в форму подбора передается параметр `ТчТоваровДокумента`, содержащий данные табличной части формы объекта. Все строки табличной части сначала «приедут» с сервера, так как на клиенте присутствует только видимая часть этих строк. Затем все они «поедут» на сервер при открытии формы подбора.

При передаче отобранных товаров обратно в форму документа в параметре процедуры `ОбработатьПодбор()` все данные таблицы значений `ОтобранныеТовары` формы подбора будут «дочитаны» с сервера на клиент.

Таким образом, количество вызовов сервера будет расти пропорционально количеству строк табличной части, так как строки «дочитываются» порциями по 35 строк, а также потенциально большой объем данных будет передаваться с сервера на клиент и обратно, что нехорошо, особенно в случае медленного соединения.

Рассмотрим теперь другой вариант.
## Второй вариант решения

На самом деле более эффективно передавать данные между формами через временное хранилище, работа с которым будет происходить на сервере. Ведь основная масса строк табличной части находится на сервере, а не на клиенте, и поэтому логично было бы передать их другой форме прямо с сервера, не «таская» их на клиент.

Для этого перед открытием формы подбора нужно сначала записать данные табличной части документа во временное хранилище, а в форме подбора прочитать его и загрузить в список отобранных товаров.

Изменим обработчик команды `Подбор` следующим образом:

```js
&НаКлиенте
Процедура Подбор(Команда)

	АдресТоваровВХранилище = ПоместитьТоварыВХранилище();
	ПараметрыПодбора = Новый Структура("АдресТоваровДокумента",
		АдресТоваровВХранилище);
	ФормаПодбора = ОткрытьФорму("Документ.РасходнаяНакладная.Форма.ФормаПодбора",
		ПараметрыПодбора, ЭтаФорма);

КонецПроцедуры
```

В этом обработчике в функции `ПоместитьТоварыВХранилище()` мы помещаем данные, выгруженные из табличной части документа, во временное хранилище. Эта функция возвращает адрес данных в хранилище – `АдресТоваровВХранилище`. Затем открываем форму подбора с параметром `АдресТоваровДокумента`, содержащим этот адрес.

Поместим в модуле формы документа функцию `ПоместитьТоварыВХранилище()`, выполняющуюся на сервере с контекстом формы:

```js
&НаСервере
Функция ПоместитьТоварыВХранилище()

	Возврат ПоместитьВоВременноеХранилище(Объект.Товары.Выгрузить(
		,"Товар,Количество"), УникальныйИдентификатор);

КонецФункции
```

В самом начале модуля формы документа мы определяем клиентскую переменную `АдресТоваровВХранилище`, чтобы потом получить по этому адресу список отобранных товаров из формы подбора:

```js
&НаКлиенте
Перем АдресТоваровВХранилище;
```

Теперь создадим в форме подбора строковый реквизит `АдресТоваровДокумента` для хранения адреса товаров в хранилище. Заполнять его будем в обработчике события формы `ПриСозданииНаСервере`:

```js
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)

	АдресТоваровДокумента = Параметры.АдресТоваровДокумента;
	ОтобранныеТовары.Загрузить(ПолучитьИзВременногоХранилища(
		АдресТоваровДокумента));

КонецПроцедуры
```

В этом обработчике мы сохраняем в реквизите `АдресТоваровДокумента` адрес товаров во временном хранилище, получаем из хранилища данные по этому адресу и загружаем их в таблицу значений `ОтобранныеТовары`.

Таким образом, список отобранных товаров при открытии формы подбора будет заполнен данными табличной части расходной накладной.

Теперь при закрытии формы подбора по нажатию кнопки `ОК` нужно записать список отобранных товаров во временное хранилище, а в форме документа прочитать его и загрузить обратно в табличную часть.

Изменим обработчик команды `ОК` следующим образом:

```js
&НаКлиенте
Процедура ОК(Команда)

	ЗаписатьПодборВХранилище();
	ВладелецФормы.ОбработатьПодбор();
	Закрыть();

КонецПроцедуры
```

Поместим в модуле формы подбора процедуру `ЗаписатьПодборВХранилище()`, выполняющуюся на сервере с контекстом формы, для записи данных таблицы значений `ОтобранныеТовары` во временное хранилище по адресу `АдресТоваровДокумента`:

```js
&НаСервере
Процедура ЗаписатьПодборВХранилище()

	ПоместитьВоВременноеХранилище(ОтобранныеТовары.Выгрузить(),
		АдресТоваровДокумента);

КонецПроцедуры
```

Процедуру `ОбработатьПодбор()` владельца формы, то есть формы объекта – документа `РасходнаяНакладная`, изменим следующим образом:

```js
&НаКлиенте
Процедура ОбработатьПодбор() Экспорт

	ПолучитьТоварыИзХранилища(АдресТоваровВХранилище);
	Модифицированность = Истина;

КонецПроцедуры
```

Поместим в модуле формы документа процедуру `ПолучитьТоварыИзХранилища()`, выполняющуюся на сервере с контекстом формы, для чтения данных из временного хранилища. В процедуру мы передаем адрес этих данных в хранилище, хранящийся в клиентской переменной `АдресТоваровВХранилище`:

```js
&НаСервере
Процедура ПолучитьТоварыИзХранилища(АдресТоваровВХранилище)

	Объект.Товары.Загрузить(ПолучитьИзВременногоХранилища(
		АдресТоваровВХранилище));

КонецПроцедуры
```

В этой процедуре мы получаем товары из временного хранилища по адресу `АдресТоваровВХранилище` и загружаем их в табличную часть документа.

Таким образом, табличная часть расходной накладной при закрытии формы подбора по кнопке `ОК` будет заполнена списком отобранных товаров.

Запустим «1С:Предприятие», откроем документ Расходная накладная №  3 (он содержит 1000 позиций товаров) и нажмем кнопку `Подбор`. После этого строки табличной части документа будут помещены во временное хранилище. Затем откроется форма подбора. При ее открытии данные из хранилища будут прочитаны и загружены в список отобранных товаров.

Посмотрим, сколько вызовов сервера при этом произойдет и какой будет объем передаваемых данных между клиентом и сервером.

![[Pasted image 20240804203118.png|500]]

Мы видим, что сервер вызывается 2 раза. Один вызов происходит при записи данных табличной части в хранилище, а второй – при открытии формы подбора методом `ОткрытьФорму()`.

Объем принятых данных отражает ситуацию, когда на клиент «приезжает» форма и видимые 35 строк табличной части.

Для наглядности рассмотрим схему передачи данных между клиентом и сервером (первый вариант решения для сравнения приведен слева), рис. 4.70.

![[Pasted image 20240804203228.png]]

После того как пользователь произведет подбор товаров из справочника (в нашем примере выбран всего один товар) и закроет форму подбора, отобранные товары и их количество будут помещены во временное хранилище. В форме документа в процедуре `ОбработатьПодбор()` данные из хранилища будут прочитаны и загружены обратно в табличную часть.

Посмотрим теперь на показатели производительности.

![[Pasted image 20240804203339.png|500]]

Здесь один вызов сервера тратится на помещение таблицы значений `ОтобранныеТовары` из формы подбора в хранилище, а второй – на чтение этих данных из хранилища в форме документа.

Объем принятых данных отражает ситуацию, когда вся табличная часть «приезжает» в форму документа на клиент, так как мы ее заново загрузили на сервере из временного хранилища.

Для наглядности рассмотрим схему передачи данных между клиентом и сервером (первый вариант решения для сравнения приведен слева), рис. 4.71.

![[Pasted image 20240804203441.png]]

Объем принятых данных близок к аналогичным показателям в первом варианте. И, действительно, все будет похоже. Здесь мы получаем всю табличную часть с сервера, и это занимает 182538. А в первом примере мы, наоборот, передавали всю табличную часть на сервер (рис. 4.70). И там это заняло 189303. В принципе, значения одинаковые, разница объясняется разными направлениями движения данных (может использоваться разная степень сжатия данных) и нюансами кеширования.

Для наглядности рассмотрим схему программного взаимодействия клиента и сервера
(рис. 4.72).

![[Pasted image 20240804203555.png]]

При открытии формы подбора из процедуры `Подбор()` один вызов сервера произойдет при записи списка товаров табличной части документа во временное хранилище, а второй вызов – собственно при открытии формы подбора.

При закрытии формы подбора из процедуры `ОК()` один вызов сервера произойдет при записи списка отобранных товаров во временное хранилище, а второй вызов – из процедуры формы документа `ОбработатьПодбор()` при чтении отобранных товаров из временного хранилища и загрузке их в табличную часть документа.

Итого 4 контекстных вызова сервера вместо 57 (в первом варианте)!

По объему передаваемых данных в первом случае получается: $153302 + 189303 + 97690 = 440 295$.

Во втором случае получается: $12536 + 182 538 = 195 074$.

То есть разница в объеме передаваемых данных больше чем в два раза!

Что показательно, в первом случае количество серверных вызовов будет увеличиваться пропорционально увеличению табличной части, а во втором варианте количество серверных вызовов будет постоянным независимо от объема табличной части. Это тоже важный момент.

Таким образом, мы видим, что при большом массиве передаваемых данных такой вариант обмена данными между формами будет более оптимальным.
## Резюме

При оптимизации клиент-серверного взаимодействия нужно стремиться не только минимизировать вызовы сервера, но и следить за объемом передаваемых данных между сервером и клиентом.

*Если можно лишний раз не передавать данные между клиентом и сервером, лучше их не передавать.*

Поэтому *при передаче данных между формой объекта и формой подбора рекомендуется использовать временное хранилище, чтение и запись которого должны выполняться на сервере.*

*Потенциально большой массив данных не рекомендуется передавать в качестве параметра формы подбора.*

Таким образом, из показанных вариантов решения задачи более эффективным будет
второй – за счет передачи данных между формами, минуя клиент, через временное хранилище.

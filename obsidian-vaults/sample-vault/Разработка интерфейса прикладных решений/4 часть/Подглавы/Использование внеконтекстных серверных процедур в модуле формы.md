---
tags:
  - 1С
---
## Задача

Серверные процедуры и функции могут исполняться с передачей контекста формы на сервер (директива компиляции `&НаСервере`) и без (директива компиляции `&НаСервереБезКонтекста`).

При контекстных серверных вызовах процедур в модуле формы форма передает свои данные (реквизиты) и элементы на сервер и обратно. Данные формы становятся доступны на сервере, но нужно понимать, что передача контекста формы на сервер – это целый непростой процесс.

Ведь контекст формы сначала на клиенте нужно подготовить к передаче, упаковать, а потом на сервере создать специальную среду, в которой будет исполняться код, развернуть весь полученный контекст, инициализировать им эту среду и т.д. После выполнения процедуры измененные данные снова «поедут» на клиент, если их нужно отображать в форме. На все это, естественно, тратится время и ресурсы системы.

Однако использование контекстных серверных процедур необходимо, когда нужно, например, поменять данные во всей табличной части или когда нужно при этом поработать с тем объектом, который отображается в форме, выполнить его экспортируемый метод и т.п.

Во внеконтекстных серверных процедурах недоступен контекст формы. Это значит, что при вызове этих процедур не происходит передача данных формы на сервер и обратно. Соответственно, производительность прикладного решения при использовании внеконтекстных серверных процедур будет выше.

Так что же использовать в том или ином случае: внеконтекстные или контекстные серверные процедуры? Решение зависит от конкретной задачи. Рассмотрим пример.

Предположим, в периодическом регистре сведений `Цены` содержатся розничные цены товаров из справочника `Товары`. Для расходования товаров существует документ `РасходнаяНакладная`, в табличную часть которого подбираются товары.

Хочется, чтобы пользователь, выбрав товар, видел в документе не только ссылку, но сразу же и цену выбранного товара из регистра сведений, актуальную на дату документа (рис. 4.21).

![[Pasted image 20240731165658.png]]

Таким образом, в тот момент, когда пользователь выбирает товар в колонке `Товар`, ссылающейся на справочник `Товары`, колонку `Цена` табличной части документа `РасходнаяНакладная` нужно заполнить актуальной ценой товара из регистра сведений.

Рассмотрим возможные варианты решения этой задачи.
## Первый вариант решения

Чтобы обеспечить подстановку актуальной цены в расходную накладную при выборе товара, мы будем «уходить» на сервер, там определять цену товара, подставлять ее в документ и затем возвращаться обратно на клиент. Ведь получить доступ к базе данных мы можем только на сервере – поэтому сразу же сделаем все, что нам нужно, прямо на сервере.

Для этого создадим форму документа и обработчик события `ПриИзменении()` для поля формы `Товар`, содержащегося в таблице формы `Товары`:

```js
&НаКлиенте
Процедура ТоварыТоварПриИзменении(Элемент)
	РозничнаяЦена();
КонецПроцедуры
```

В этом обработчике мы вызываем контекстную серверную процедуру `РозничнаяЦена()`. Эту процедуру мы поместим в модуле формы документа:

```js
&НаСервере
Процедура РозничнаяЦена()

	Идентификатор = Элементы.Товары.ТекущаяСтрока;
	ДанныеТекущейСтроки = Объект.Товары.НайтиПоИдентификатору(Идентификатор);

	Отбор = Новый Структура;
	Отбор.Вставить("Товар", ДанныеТекущейСтроки.Товар);
	ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(Объект.Дата,
		Отбор);
	ДанныеТекущейСтроки.Цена = ЗначенияРесурсов.Цена;

КонецПроцедуры
```

В этой процедуре мы получаем Идентификатор текущей строки таблицы формы. По этому идентификатору находим эту строку в объекте `ДанныеФормыКоллекция`, содержащем табличную часть документа –` Объект.Товары`. Таким образом мы получаем доступ к данным текущей строки таблицы формы в переменной `ДанныеТекущейСтроки` и через точку от нее можем обращаться к значению колонок таблицы.

Затем мы создаем структуру `Отбор`, содержащую отбор по измерению регистра `Товар`, и устанавливаем его равным ссылке на выбранный товар (`ДанныеТекущейСтроки.Товар`).

Затем мы выполняем метод менеджера регистра сведений Цены `ПолучитьПоследнее()` и присваиваем значение ресурса `Цена` наиболее поздней записи регистра на дату документа (`Объект.Дата`) для выбранного товара (`Отбор`) соответствующей колонке таблицы формы.

Заметьте, что значения реквизитов документа (`Объект.Дата`, `Объект.Товары`) и свойства элементов формы (`Элементы.Товары.ТекущаяСтрока`) доступны на сервере, так как при использовании директивы компиляции `&НаСервере` в процедуру передается весь контекст формы.

Запустим «1С:Предприятие», откроем расходную накладную, добавим запись в табличную часть документа и сделаем выбор из справочника товаров в колонке `Товар`. После этого колонка табличной части `Цена` автоматически заполнится последней ценой из регистра сведений, актуальной на дату документа для выбранного товара (рис. 4.22).

![[Pasted image 20240731170613.png|600]]

В результате использования процедуры `РозничнаяЦена()` для подстановки цены в документ будет происходить одно обращение на сервер (рис. 4.23)

![[Pasted image 20240731171103.png|400]]


> Заметим, что при первом выборе товара может быть лишний серверный вызов за счет автоматического кеширования формой данных в списке выбора. Но мы не будем исследовать эту ситуацию, так как этот вызов делается платформой, а нас интересуют вызовы, инициированные разработчиком.
## Второй вариант решения

Один вызов сервера, происходящий при подстановке цены товара, неизбежен и оправдан. Но обратите внимание на объем данных, передаваемых на сервер и обратно, указанный на рисунке 4.23 (чтобы его увидеть, нужно включить соответствующие опции в окне настройки показателей производительности). Можно ли его уменьшить? Конечно! Действительно, зачем «гонять» весь контекст формы туда и обратно, когда нам нужна всего лишь одна цена товара?

На самом деле в функции для получения актуальной цены `РозничнаяЦена()` кроме ссылки на выбранный товар используется только один реквизит документа `РасходнаяНакладная` – `Дата`. Вместо того чтобы передавать весь контекст формы на сервер, можно передать эти значения в функцию в качестве параметров. Описание функции в модуле формы мы предварим директивой компиляции `&НаСервереБезКонтекста`. Таким образом мы не будем передавать данные формы на сервер, и наше прикладное решение будет работать быстрее.

И если раньше мы подставляли цену в документ на сервере, то теперь мы будем делать это на клиенте. Именно для этого действия сервер совершенно не нужен, это можно прекрасно сделать прямо на клиенте.

Для этого изменим обработчик события `ПриИзменении()` поля Товар табличной части документа `РасходнаяНакладная` следующим образом:

```js
&НаКлиенте
Процедура ТоварыТоварПриИзменении(Элемент)

	ДанныеТекущейСтроки = Элементы.Товары.ТекущиеДанные;
	ДанныеТекущейСтроки.Цена = РозничнаяЦена(ДанныеТекущейСтроки.Товар,
		Объект.Дата);

КонецПроцедуры
```

В этом обработчике мы получаем доступ к данным текущей строки таблицы формы в переменной `ДанныеТекущейСтроки` и через точку от нее можем обращаться к значению колонок таблицы. Ссылку на выбранный товар (`ДанныеТекущейСтроки.Товар`) и дату документа (`Объект.Дата`) мы передаем в функцию для получения актуальной цены `РозничнаяЦена()` и присваиваем возвращенное значение колонке табличной части `Цена`.

В модуле формы документа поместим функцию `РозничнаяЦена()`, выполняющуюся на сервере без контекста формы:

```js
&НаСервереБезКонтекста
Функция РозничнаяЦена(ВыбранныйТовар, АктуальнаяДата)

	Отбор = Новый Структура;
	Отбор.Вставить("Товар", ВыбранныйТовар);
	ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(АктуальнаяДата,
		Отбор);

	Возврат ЗначенияРесурсов.Цена;

КонецФункции
```

В этой функции мы создаем структуру `Отбор`, содержащую отбор по измерению регистра Товар, и устанавливаем отбор равным ссылке на выбранный товар. Затем при помощи метода `ПолучитьПоследнее()` мы возвращаем актуальную цену выбранного товара.

Запустим «1С:Предприятие», откроем расходную накладную и сделаем выбор из справочника товаров в колонке Товар табличной части документа. После этого колонка табличной части Цена автоматически заполнится последней ценой из регистра сведений, актуальной на дату документа для выбранного товара (рис. 4.24).

![[Pasted image 20240731171941.png]]

Как мы видим, функциональность прикладного решения будет такой же, как и в первом случае, но объем передаваемых на сервер данных будет значительно меньше (вместо 2481 – 1886 байт), так как при вызове функции `РозничнаяЦена()` мы использовали внеконтекстный серверный вызов и не передавали все данные формы на сервер (рис. 4.25).

![[Pasted image 20240731171956.png|400]]

Но, с другой стороны, использование процедур с параметрами тоже может иметь свои недостатки. Слишком большое количество параметров в процедуре может снижать производительность. «Слишком большое» – понятие относительное, конкретные числовые оценки дать нельзя. Но, например, если есть выбор: передать 100 параметров или передать всего 2 параметра, – то, конечно же, нужно передавать 2 параметра, а не 100. Поэтому разработчику всегда нужно искать компромисс между здравым смыслом («читабельностью» программы) и оптимизацией.

В связи с этим можно на клиенте формировать структуру параметров, передаваемых в функцию, и затем передавать ее целиком, одним параметром.

В данном конкретном случае мы передаем всего два параметра. Это нормально – можно передавать их по отдельности, и нет необходимости сокращать их количество. Но на этом примере мы покажем, как в принципе можно это сделать. Например, сгруппировать логически связанные между собой параметры в один, который является структурой.

Итак, объединим два параметра, передаваемых в функцию для получения актуальной цены, в структуру, и передадим ее целиком как структуру параметров:

```js
&НаКлиенте
Процедура ТоварыТоварПриИзменении(Элемент)

	ДанныеТекущейСтроки = Элементы.Товары.ТекущиеДанные;
	Отбор = Новый Структура("Товар", ДанныеТекущейСтроки.Товар);
	ПараметрыФункции = Новый Структура("Отбор, АктуальнаяДата", Отбор,
		Объект.Дата);
	ДанныеТекущейСтроки.Цена = РозничнаяЦена(ПараметрыФункции);

КонецПроцедуры
```

```js
&НаСервереБезКонтекста
Функция РозничнаяЦена(ПараметрыФункции)

	ЗначенияРесурсов = РегистрыСведений.Цены.ПолучитьПоследнее(
		ПараметрыФункции.АктуальнаяДата, ПараметрыФункции.Отбор);

	Возврат ЗначенияРесурсов.Цена;

КонецФункции
```

Обратите внимание, если мы сравним объем передаваемых данных, то оказывается, что он больше, чем когда мы передавали параметры в функцию по отдельности (рис. 4.26).

![[Pasted image 20240731172403.png|400]]

Получается, что для данного примера это действительно ненужная «оптимизация». Как мы и говорили, два параметра в этом примере – это хорошо, и мы даже получили увеличение объема передаваемых данных, когда упаковали их в одну структуру. Но когда параметров слишком много, ситуация может быть обратной. Поэтому в каждой ситуации нужно думать, как лучше поступить, и упаковка параметров в один должна быть логически понятна и объяснима
## Резюме

Применение внеконтекстных процедур позволяет значительно уменьшить объем передаваемых данных (трафик) между клиентом и сервером и уменьшить нагрузку на систему

Контекстную передачу управления на сервер целесообразно использовать при работе с большими объемами данных (реквизитами формы типа табличных документов или коллекциями элементов типа `ДанныеФормыКоллекция`, `ДанныеФормыСтруктураСКоллекцией`, `ДанныеФормыДерево`). В этих случаях платформа «1С:Предприятие» самостоятельно оптимизирует объем передаваемых между клиентом и сервером данных (в обоих направлениях). При этом затраты ресурсов сервера на инициализацию контекста формы оправдываются существенным снижением трафика между клиентом и сервером и снижением числа вызовов сервера.

_В остальных случаях нужно использовать внеконтекстные серверные процедуры, а если требуется передавать туда какие-то данные формы, то можно одно-два значения передать в качестве параметров._

_Не нужно без необходимости использовать контекстные серверные процедуры, если в них не требуется использовать и изменять большинство реквизитов формы._

Таким образом, из показанных вариантов решения задачи более эффективным будет второй – за счет использования внеконтекстного серверного вызова.

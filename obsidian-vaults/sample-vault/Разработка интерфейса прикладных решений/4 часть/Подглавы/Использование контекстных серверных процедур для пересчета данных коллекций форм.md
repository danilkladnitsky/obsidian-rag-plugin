---
tags:
  - 1С
---
## Задача

Теперь рассмотрим пример, когда пересчет данных формы более эффективно выполнять на сервере. Мы уже говорили в предыдущем примере, что на сервере вычисления необходимо выполнять, когда на клиенте нет нужных типов данных, или когда используется сложный алгоритм расчета, содержащий много кода, или когда требуется обратиться к объекту, содержащемуся в форме, напрямую.

Однако в данном примере будет рассмотрен другой вопрос: где наиболее эффективно выполнять пересчет большого количества строк табличной части – на сервере или на клиенте?

С одной стороны, на серверный контекстный вызов платформа тратит время и ресурсы. Желательно бы этого избегать.

С другой стороны, на клиенте присутствуют не все строки коллекций форм (табличных частей, таблиц значений), а только их видимая часть. Остальные «дочитываются» с сервера динамически, по мере того как пользователь прокручивает таблицу. Или по мере того как разработчик перебирает коллекцию данных в реквизите формы из встроенного языка.

Таким образом, при массовом пересчете на клиенте все строки табличной части будут получены с сервера на клиент и все вернутся обратно при следующем контекстном вызове сервера.

Посмотрим, какое решение более оптимально. Рассмотрим пример.

Предположим, в табличной части расходной накладной содержатся товары и их цены. При нажатии кнопки `Пересчет цен`, расположенной в форме документа, должно производиться повышение цен товаров на 10 %, а также пересчет сумм продажи товаров как произведения их количества и цены (рис. 4.30).

![[Pasted image 20240731194038.png]]

Рассмотрим возможные варианты решения этой задачи.
## Первый вариант решения

Чтобы обеспечить пересчет цен товаров в табличной части расходной накладной, не будем вызывать сервер. Пересчитаем все цены на клиенте, ведь все необходимые данные на нем есть и обращаться к серверу вроде бы незачем.

Для этого создадим форму документа и ее команду `ПересчетЦен`. Перетащим команду в командную панель таблицы формы `Товары`. Обработчик команды заполним следующим образом:

```js
&НаКлиенте
Процедура ПересчетЦен(Команда)

Для Каждого ТекСтрокаТовары Из Объект.Товары Цикл

	ТекСтрокаТовары.Цена = ТекСтрокаТовары.Цена * 1.1;
	ТекСтрокаТовары.Сумма = ТекСтрокаТовары.Количество * ТекСтрокаТовары.Цена;

КонецЦикла;

КонецПроцедуры
```

В этом обработчике мы в цикле обходим табличную часть документа и пересчитываем цены и суммы товаров.

Запустим «1С:Предприятие», откроем документ `РасходнаяНакладная` №2 (он содержит 1000 позиций товаров) и нажмем кнопку `Пересчет цен`. После этого цены и суммы товаров пересчитаются по заданному нами алгоритму (рис. 4.30).

Пересчет всех строк табличной части произойдет непосредственно на клиенте. Но при нажатии кнопки `Пересчет цен` произойдет двадцать восемь вызовов сервера (рис. 4.31).

![[Pasted image 20240731194344.png|400]]

Так происходит потому, что при открытии формы на клиент передается 35 строк табличной части, и затем, по мере программного обращения, остальные строки «дочитываются» с сервера порциями по 35 строк $(1015 = 28 * 35 + 35)$.

В процессе пересчета все недостающие $(965 = 1 000 - 35)$ строки «приедут» с сервера на клиент. При следующем контекстном вызове все измененные данные, то есть все 1000 строк, «поедут» обратно на сервер (рис. 4.32).

![[Pasted image 20240731194654.png]]

Например, сделаем команду `Вызов сервера`, после пересчета цен вызовем из нее пустую серверную контекстную процедуру и посмотрим на показатели производительности (рис. 4.33).

![[Pasted image 20240731194753.png|400]]

Для наглядности рассмотрим схему передачи данных между клиентом и сервером (рис. 4.34).

![[Pasted image 20240731194827.png]]

Рассмотрим подробнее, сколько вызовов сервера при этом произойдет и каков будет объем передаваемых данных между клиентом и сервером. Мы специально рассматриваем пример документа с большой табличной частью, так как на нем лучше сравнивать показатели производительности.

![[Pasted image 20240731194918.png]]

При открытии формы 2 вызова сервера происходят при открытии формы в первый раз, при следующем открытии – 1 вызов.

Объем принятых данных отражает ситуацию, когда на клиент «приезжают» форма и «видимые» 35 строк табличной части.

При пересчете табличной части 28 вызовов сервера тратятся на «дочитывание» строк табличной части документа на клиент порциями по 35 строк.

Объем принятых данных отражает ситуацию, когда табличная часть «доехала» в форму документа на клиент.

Объем отправленных данных отражает ситуацию, когда форма сообщает серверу, какие строки и в каком порядке получить.

При следующем контекстном вызове объем отправленных данных отражает ситуацию, когда все 1000 измененных строк табличной части «уезжают» на сервер.

Таким образом, объем принятой информации – $16 343 + 161774 = 178117$ байтов, а объем отправленной – 205591 байт.

Если сравнить объем принятых и переданных данных, то получится, что форма и 1000 строк, переданные на клиент, меньше, чем 1000 строк, переданных с клиента на сервер. Это действительно так, потому что обратно передаются не только строки, но и служебная информация о том, что строка изменена.

Таким образом, в первом случае 161 774 байта информации передается на клиент и 205591 байт передается на сервер. Как видите, объем передаваемых данных будет довольно большим ($161774 + 205591 = 367 365$ байтов). На самом деле, как будет показано ниже, более эффективно этот расчет будет работать на сервере.
## Второй вариант решения

Форма всегда создается на сервере, а не на клиенте. Таким образом, при открытии формы все данные для пересчета уже есть на сервере. Поэтому лучше выполнять пересчет строк табличной части на сервере, а не на клиенте, так как строки для пересчета не будут передаваться на клиент.

Поэтому в данном решении мы сразу «уйдем» на сервер вместе с контекстом формы и там все пересчитаем. И затем вернемся на клиент.

Для этого изменим обработчик команды `ПересчетЦен` документа `РасходнаяНакладная` следующим образом:

```js
&НаКлиенте
Процедура ПересчетЦен(Команда)
	ПересчетЦенНаСервере();
КонецПроцедуры
```

В этом обработчике мы вызываем серверную контекстную процедуру `ПересчетЦенНаСервере()`. Поместим ее в модуле формы

```js
&НаСервере
Процедура ПересчетЦенНаСервере()

	Для Каждого ТекСтрокаТовары Из Объект.Товары Цикл
		ТекСтрокаТовары.Цена = ТекСтрокаТовары.Цена * 1.1;
		ТекСтрокаТовары.Сумма = ТекСтрокаТовары.Количество * ТекСтрокаТовары.Цена;
	КонецЦикла;

КонецПроцедуры
```

Запустим «1С:Предприятие», откроем документ `РасходнаяНакладная` №2 (он содержит 1000 позиций товаров) и нажмем кнопку `Пересчет цен`. После этого цены и суммы товаров пересчитаются по заданному нами алгоритму.

Посмотрим на схему программного взаимодействия клиента и сервера в этом случае (рис. 4.35).


![[Pasted image 20240731202955.png]]

Функциональность прикладного решения будет такой же, как и в первом случае, но производительность будет выше, хотя мы и _выполнили контекстный серверный вызов_.

Посмотрим теперь на показатели производительности при нажатии кнопки `Пересчет цен` (рис. 4.36).

![[Pasted image 20240731203020.png|400]]

Для наглядности рассмотрим схему передачи данных между клиентом и сервером (первый вариант решения для сравнения приведен слева) – рис. 4.37

![[Pasted image 20240731203049.png]]

Рассмотрим подробнее, сколько вызовов сервера при этом произойдет и каков будет объем передаваемых между клиентом и сервером данных. Мы специально рассматриваем пример документа с большой табличной частью, так как на нем лучше сравнивать показатели производительности.

![[Pasted image 20240731203129.png]]

При пересчете табличной части на сервере объем принятых данных отражает ситуацию, когда все 1000 измененных строк табличной части «приезжают» на клиент.

Таким образом, во втором варианте передается 205 006 байтов информации против 367 365 байтов в первом. Заметим, что мы здесь сравниваем только объем передаваемых данных, инициируемый разработчиком.
## Резюме

Все данные формы изначально доступны на сервере при ее открытии. В частности, на сервере присутствуют все строки табличных частей, а на клиенте – только их видимая часть.

Поэтому _изменять данные коллекций форм (табличные части, таблицы значений) лучше на сервере. Если же аналогичные действия выполнять на клиенте, то все данные коллекций форм будут переданы на клиент, хотя они не требуются для отображения в форме._

Таким образом, из показанных вариантов решения задачи более эффективным будет второй – за счет того, что данные табличной части изменяются на сервере, а значит, не происходит ненужная предварительная передача всей табличной части на клиент.
